A Description of the `librematch` Regex Engine.
====

This document is a recollection of the development of the `librematch`
regex engine. The aim in writing this document is for it to be a guide,
and that inconsistencies be identified and addressed.

Quantification
====

The first issue to address, is that of quantification. The envisioned process
is a simple two-branch testing:

- Try next atom,
- Try repeating the current atom.

Whichever is a better match, the process get carried out recursively under
that branch. Whether or not a match is 'better' is determined based on the
qualification of the quantifier and the overall expression (greedy or minimal)
and the current record.

Once the end of the expression is reached, the record is saved to the matches
structure array.

Alternatives
====

Before the two-branch testing happens, alternatives (delimited by `|`)
need to be identified. At the start of the expression, before two-branch testing
take place, all alternatives are taken into consideration for testing - this
doesn't occur for atoms not at the beginning of the expression, because they're
part of the alternative slice that the first atom in the slice begins.

The alternatives, together with the two-branch testing, constitutes the
twice alternatives branches testing.

Grouping / Subexpression
====

Because the betterness of a match must be tested by the time the end of the
expression is reached, each branch-test must continue recursively with the
next or the re-quantified atom. This include the case when it's the end of
a subexpression or an alternative slice in a subexpression - when it's such
an end, the two-branch testing continues with that of the parent.

Also as such, each subexpression atom are entered from their starting atom,
then proceed through. Each invocation of matcher function therefore
do not return to indicate matches of individual atoms, instead, they invoke
themselves recursively, and consult the return status and report those to
the caller.

Empty Slice
----

There are occasional cases where a empty alternative is a valid construct
that matches certain strings, but unlimited quantification can lead to
infinite loop then stack overflow. For these cases, subexpressions will not
proceed to the next atom in parent as soon as minimal repetition is reached.

Capture
====

Capturing of subexpressions is an important consideration for API conformance.
Only the last of the repetitions are captured - in the code, it's reflected
by saving the match corresponding to the largest quantification `q`; on tie,
deeper call stack levels triumphs after matches that can be determined to be
'definitely better'.

Because there are branching between different matches, the one remembered
may not be the best. So matches are first 'saved', then when the current
branch determines that this match is better than the previous, it 'remembers'
this saved match.

Backreference
----

The limited backreference support in BRE mode require that captures be
remembered for future use, this is in conflict with the save before remember
approach mentioned earlier, so a separate 'back-reference' field is reserved
for this purpose.

Document Info
====

This note is created on 2025-09-09.
